============ Sqlite ======================


sqlite> select count(*) from tweets where is_delete = 1;
1554

-----------------------------------
sqlite> select count(*) from tweets where reply_to != 0;
2531

-----------------------------------

// deleted tweets included
sqlite> select uid, count(*) as c from tweets group by uid order by c desc limit 5;
320820996|87
1106510150|80
183997528|65
118947331|61
206109994|61


// deleted tweets not included
sqlite> select uid, count(*) as c from tweets where is_delete = 0 group by uid order by c desc limit 5;
1269521828|5
392695315|4
424808364|3
1706901902|3
23991910|2

-----------------------------------

sqlite> select places.id, places.name, count(*) as c from tweets, places where places.tid = tweets.id group by places.id order by c desc limit 5;
682c5a667856ef42|Türkiye|4
25f5e9dbc1b635ac|Gambir|3
8f6d8fbc7060e679|East Borneo|3
034ab67b4e0af012|Nongsa|2
0f0c6990d5e6479a|Malalayang|2

-----------------------------------

========= NOTE, inconsistent data -- please fix ============
sqlite> select * from places where id = '8f6d8fbc7060e679';
373701967102885888|https://api.twitter.com/1.1/geo/id/8f6d8fbc7060e679.json|Indonesia|ID|admin|8f6d8fbc7060e679|Kalimantan Timur
373701975499489280|https://api.twitter.com/1.1/geo/id/8f6d8fbc7060e679.json|Indonesia|ID|admin|8f6d8fbc7060e679|East Borneo
373702160040460291|https://api.twitter.com/1.1/geo/id/8f6d8fbc7060e679.json|Indonesia|ID|admin|8f6d8fbc7060e679|East Borneo
sqlite> 



###################### Mongo DB ##########################

> db.tweets.find({'delete.status.id': {$gt: 0}}).count()
1554

-----------------------------------

> db.tweets.find({'in_reply_to_status_id': {$gt: 0}}).count()
2531
> 

-----------------------------------

// deleted tweets not included
> db.tweets.aggregate({$match: {'user.id': {$gt: 0}}}, {$group: {_id: '$user.id', count: {$sum: 1}}}, {$sort: {count: -1}}, {$limit: 5} );
{
	"result" : [
		{
			"_id" : 1269521828,
			"count" : 5
		},
		{
			"_id" : 392695315,
			"count" : 4
		},
		{
			"_id" : 424808364,
			"count" : 3
		},
		{
			"_id" : 1706901902,
			"count" : 3
		},
		{
			"_id" : 364117533,
			"count" : 2
		}
	],
	"ok" : 1
}
> 

-----------------------------------

> db.tweets.aggregate({$match: {'place.id': {$gt: ''}}}, {$group: {_id: '$place.id', name: {$last: '$place.name'}, count: {$sum: 1}}}, {$sort: {count: -1}}, {$limit: 5} );
{
	"result" : [
		{
			"_id" : "682c5a667856ef42",
			"name" : "Türkiye",
			"count" : 4
		},
		{
			"_id" : "25f5e9dbc1b635ac",
			"name" : "Gambir",
			"count" : 3
		},
		{
			"_id" : "8f6d8fbc7060e679",
			"name" : "East Borneo",
			"count" : 3
		},
		{
			"_id" : "0f0c6990d5e6479a",
			"name" : "Malalayang",
			"count" : 2
		},
		{
			"_id" : "034ab67b4e0af012",
			"name" : "Nongsa",
			"count" : 2
		}
	],
	"ok" : 1
}
> 

-----------------------------------

###################### Protocol Buffer ##########################

1554
-----------------------------------
2531
-----------------------------------
[(320820996, 87), (1106510150, 80), (183997528, 65), (206109994, 61), (118947331, 61)]
[(1269521828L, 5), (392695315L, 4), (424808364L, 3), (1706901902L, 3), (1471774728L, 2)]
-----------------------------------
[(u'682c5a667856ef42', u'T\xfcrkiye', 4), (u'25f5e9dbc1b635ac', u'Gambir', 3), (u'8f6d8fbc7060e679', u'East Borneo', 3), (u'034ab67b4e0af012', u'Nongsa', 2), (u'43d2418301bf1a49', u'Mississippi', 2)]
-----------------------------------

###################### Reflection ##########################

-----------------------------------
Read the schema and protocol buffer definition files. What are the main differences between the two? Are there any similarities?

Similarities: 
1. Both have Data Types
2. Both specify references
3. Both are schema-first

Differences:
1. Protocol Buffer is Hierarchical
2. Protocol Buffer can be encoded and decoded so very useful for serialization
3. Databases has nice Query Language (SQL) -- Protocol Buffer doesn't have it 
-----------------------------------

-----------------------------------
Describe one question that would be easier to answer with protocol buffers than via a SQL query.

Protocol Buffer is not a query language but rather a serialization/de-serialization interface so not sure if this question even applies.
-----------------------------------


-----------------------------------
Describe one question that would be easier to answer with MongoDB than via a SQL query.

One thing mongo is good at is it lets you write your own mapper and reducer which is difficult to do in SQL.
-----------------------------------


-----------------------------------
Describe one question that would be easier to answer via a SQL query than using MongoDB.

Group By, Projection, Selection (most are much more intuitive/easier in SQL)
-----------------------------------

-----------------------------------
What fields in the original JSON structure would be difficult to convert to relational database schemas?

In theory, all fields can be stored. Practically, those fields that are not part of every tweet (although NULL can value can be stored, it's still much easier to convert to ProtocolBuffer than relational schema) are very difficult to convert to relational schema.

-----------------------------------
In terms of lines of code, when did various approaches shine? Think about the challenges of defining schemas, loading and storing the data, and running queries.
What other metrics (e.g., time to implement, code redundancy, etc.) can we use to compare these different approaches? Which system is better by those measures?

Mongo DB: no schema definition, but difficult/not intuitive for writing complex queries, slow performance

SQL -- Requires Schema first, SQL queries are intuitive but complex nested queries get very difficult and un-intuitive (still much better than mongo), fast performance, a lot of storage and indexing optimization

Protocol Buffer -- great for serialization, allows extendibility of schema, reasonable performance, but querying is difficult -- most querying logic need to be written in a programming language, uses binary format for serialization
-----------------------------------

-----------------------------------
How long did this lab take you? We want to make sure to target future labs to not take too much of your time.

2 hours
-----------------------------------

